<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>手写源码</title>
</head>
<body>
	<script type="text/javascript">
	/**
	 * 先把环境搭建好，保存好之前的变量（快照），全局变量和反复使用的变量的简写
	 * @return {[type]} [description]
	 */
		(function(){
			var root=this;//定义一个root,服务器下是exports,浏览器下是window
			var previousUnderscore=root._;//保存之前的_变量;undescode会导出一个_
			var ArrayProto=Array.prototype,
				FuncProto=Function.prototype,
				ObjProto=Object.prototype;
			//保存常用的方法
			var push=ArrayProto.push,
				slice=ArrayProto.slice
				concat=ArrayProto.concat,
				toString=ObjProto.toString,
				hasOwnProperty=ObjProto.hasOwnProperty;
			//希望用到的ES5原生方法
			var nativeIsArrray=Array.isArray,
				nativeKeys=Object.keys,
				nativeBind=FuncProto.bind;//Function.prototype.bind
	//要点一：安全引用(单例模式) ----------------------
	//使用underscode创立一个安全的引用,确保调用_的（即obj）都是_的实例（或实例下的属性）
	//_就是一个构造函数，可以被实例化，实例化之后的对象拥有_定义的方法和属性
			var _ = function(obj){
				//如果obj是_的一个实例，那么返回obj
				if(obj instanceof _){
					return obj;
				}
				//如果obj和引用_方法的对象都不是_的实例，则返回一个新创建的实例
				if(!this instanceof _){
					return new _();
				}
				//如果引用_方法的对象是_的实例，那么把obj赋在下面的wrapped属性
				this.wrapped=obj;
			}
	//要点二：挂载到全局
	//运行在服务器端时，在node下导出underscode变量；客户端为root._
			if(typeof exports !=='undefined'){
				//兼容module.exports版本
				if(typeof module !=='undefined'&&module.exports){
					exports=module.exports=_;
				}
			}else{				
				root._ = _;
			}
			_.VERSON='1.7.0';
		//内部函数
			//返回一个更有效率的回调函数：函数 函数环境 函数参数
			var optimizeCb=function(func,context,argCount){
				//这里用void 0代替undefined 不仅是能节省字节，还能防止undefined被重写出现的问题，void 0始终等于真正的undefined
				if(context==void 0){return func;}
				//argCount代表有几个变量，默认为3
				switch(argCount==null?3:argCount){
					case 1:return function(value){
							return func.call(context,value);
						};
					case 2:return function(value,other){
						return func.call(context,value,other);
						};
					case 3:return function(value,index,collection){
						return func.call(context,value,index,collection);
					    };
					case 4:return function(accumulator,value,index,collection){ 
                        return func.call(accumulator,value,index,collection);
						};
					}
				return function(){
					return func.applay(context,arguments);
				};
			};
			//迭代器:迭代函数 函数环境 函数参数
			//生成一个可以应用到容器中每一个元素的回调函数，并返回你想要的结果
			   cb=function(value,context,argCount){
			   //没有参数时，返回一个能返回参数本身的函数
			   if(value == null)return _.identify;
			   //value为函数时，返回一个在context作用域下接收argCount个参数，并执行value函数
			   if(_.isFunction(value)) return optimizeCb(value,context,argCount);
			   //value为对象时，返回一个函数，检测是否包含value
			   if(_.isObject(value))return _.matcher(value);//_.matcher=_.matches
			   //其他情况，返回一个函数，该含糊返回参数obj中value属性的值
			   return _.property(value);
			};
			_.iteratee=function(value,context){
				return cb(value,context,Infinity);
			}
			//内部函数
			var cerateAssigner=function(keysFunc,undefinedOnly){
				return function(obj){
						var len=arguments.length;
						if(len<2||obj==null) return obj;

				};

			}
			//一个空函数，用于构造函数的载体
			var Ctor=function(){};
	//知识点：返回一个以property为原型的构造函数的实例；扩展了Object.create()
			var baseCerate=function(property]){
				if(!_.isObject(property))return {};
				if(nativeCreate) return nativeCreate(property);
				Ctor.prototype=property;
				var result=new Ctor;
				Ctor.prototype=null;
				return result;
			}
	//数组方法
			//1.forEach:
			_.each=_.forEach=function(obj,iteratee,context){
				iteratee=optimize(iteratee,context);
				var i,len;
				if(isArray(obj)){}
			}
	//知识点：判断是不是一个数组
			_.isArray=nativeIsArray||function(obj){
				//Object.prototype.toString.call(arr)=>"[object Array]"
				return toString.call(obj)==='[object Array]';

			};
	//知识点：判断obj是不是一个对象（非空），函数也是对象
			//&& 优先级高于 || ，!!obj是为了防止obj为null
			_.isProject=function(obj){
				var type= typeof obj;
				return type ==='function' || type === 'object' && !!obj;
			}
		//解决IE11下正则表达式会被认为是一个函数的问题,Safari8 bug问题
			if(typeof /./ !='function'&&Int8Array!='object'){
				_.isFunction=function(obj){
					return typeof obj =='function' || false;
				};
			}
	//知识点：判断obj中是否含有自有属性key
		_.has=function(obj,key){
			return obj !=null && hasOwnProperty.call(obj,key);
		}
	//知识点：返回obj本身所有的key值(自有属性的keys)
		_.keys=function(obj){
			if(!_.isObject(obj)){return [];}
			if(nativeKeys){return nativeKeys(obj);}
			//不支持Object.keys()就只能遍历obj属性了
			var keys=[];
			for(var key in obj){
				if(_.has(obj,key)){keys.push(key);}
			}
			return keys;
		}
	//知识点：将obj中的键值以[key,value]形式的数组返回
		_.pairs=function(obj){
			var keys=_.keys(obj);
			    len=keys.length;
			 var pairs=Array(len);
			 for(var i=0;i<len;i++){
			 	pairs[i]=[keys[i],obj[keys[i]]];
			 }
			return pairs;
			/*我的想法
			_.pairs=function(obj){
				var pairs=[];
				if(typeof obj != 'object' || typeof obj == 'null'){return [];}
				for(var key in keys){
					pairs[i] =_=冲突了=>把obj所有的键保存在数组里再遍历赋值吧！
				}
			}
			 */
		};
		//能返回参数本身的函数
		_.identity=function(value)
			return value;
		}
		//闭包 返回一个函数 该函数返回参数obj中key属性的值
		_.property=function(key){
			return function(obj){
				return obj==null?null:obj[key];
			}
		}


			//collection functions
			//array functions
			//function functions
			//object functions
			//utility functions
			//oop
			//取出包装属性
			_.prototype.value=function(){
				return this.wrapped;
			}
	//要点四：注册AMD 
	//打包成AMD模块，导出_函数模型
			if(typeof define==='function'&&define.amd){
				define('underscode',[],function(){
					return _;
				});
			}

		}).call(this);
	</script>
</body>
</html>